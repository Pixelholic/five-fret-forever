import { parseMidi } from "midi-file";
const STANDARD_EVENTS = [
  "[idle]",
  "[play]",
  "[solo_on]",
  "[solo_off]",
  "[wail_on]",
  "[wail_off]",
  "[ow_face_on]",
  "[ow_face_off]",
  "[half_tempo]",
  "[normal_tempo]"
];
const TRACK_0_EVENTS = [
  "[lighting (chase)]",
  "[lighting (strobe)]",
  "[lighting (color1)]",
  "[lighting (color2)]",
  "[lighting (sweep)]",
  "[crowd_lighters_fast]",
  "[crowd_lighters_off]",
  "[crowd_lighters_slow]",
  "[crowd_half_tempo]",
  "[crowd_normal_tempo]",
  "[crowd_double_tempo]",
  "[band_jump]",
  "[sync_head_bang]",
  "[sync_wag]",
  "[lighting ()]",
  "[lighting (flare)]",
  "[lighting (blackout)]",
  "[music_start]",
  "[verse]",
  "[chorus]",
  "[solo]",
  "[end]"
];
const defaultOptions = {
  placeholderName: "Chart",
  omitEmptySections: true
};
function mid2Chart(buf, warns, optionsIn) {
  const options = {
    ...defaultOptions,
    ...optionsIn
  };
  let XSingle = "[ExpertSingle]\n{\n";
  let HSingle = "[HardSingle]\n{\n";
  let MSingle = "[MediumSingle]\n{\n";
  let ESingle = "[EasySingle]\n{\n";
  let Sync = "";
  let Events = "[Events]\n{\n";
  let XLead = "[ExpertDoubleGuitar]\n{\n";
  let HLead = "[HardDoubleGuitar]\n{\n";
  let MLead = "[MediumDoubleGuitar]\n{\n";
  let ELead = "[EasyDoubleGuitar]\n{\n";
  let XBass = "[ExpertDoubleBass]\n{\n";
  let HBass = "[HardDoubleBass]\n{\n";
  let MBass = "[MediumDoubleBass]\n{\n";
  let EBass = "[EasyDoubleBass]\n{\n";
  let XDrums = "[ExpertDrums]\n{\n";
  let HDrums = "[HardDrums]\n{\n";
  let MDrums = "[MediumDrums]\n{\n";
  let EDrums = "[EasyDrums]\n{\n";
  let Header = "[Song]\n{\n";
  let scaler = 0;
  let chartName = options.placeholderName;
  let coop = "bass";
  let valid = true;
  let hasEvents = false;
  function main() {
    const midi = parseMidi(new Uint8Array(buf));
    const trackArr = midi.tracks;
    let named = false;
    let j = 0;
    let name = "";
    let i;
    for (i = 0; i < trackArr.length; i++) {
      const track = trackArr[i];
      while (!named && j < track.length) {
        const event = track[j];
        if (event.type === "trackName") {
          name = event.text;
          named = true;
        }
        j++;
      }
      if (name === "PART GUITAR")
        valid = true;
      if (name === "EVENTS")
        hasEvents = true;
    }
    if (!valid) {
      throw new Error("PART GUITAR not found - cannot create chart!");
    }
    scaler = 192 / midi.header.ticksPerBeat;
    writeSync(trackArr[0]);
    Header += '	Name = "' + chartName + '"\n';
    Header += "	Offset = 0\n";
    Header += "	Resolution = 192\n";
    for (i = 1; i < trackArr.length; i++) {
      const track = trackArr[i];
      named = false;
      j = 0;
      name = "";
      while (!named && j < track.length) {
        const event = track[j];
        if (event.type === "trackName") {
          name = event.text;
          named = true;
        }
        j++;
      }
      if (named) {
        if (name === "PART GUITAR") {
          writeNoteSection(track, 0);
          valid = true;
        } else if (name === "PART GUITAR COOP") {
          writeNoteSection(track, 1);
        } else if (name === "PART RHYTHM") {
          coop = "rhythm";
          writeNoteSection(track, 3);
        } else if (name === "PART BASS") {
          writeNoteSection(track, 3);
        } else if (name === "EVENTS") {
          writeNoteSection(track, 4);
        } else if (name === "PART DRUMS") {
          writeNoteSection(track, 5);
        } else {
          warns.push("Track " + i + " (" + name + ") ignored.");
        }
      }
    }
    Header += "	Player2 = " + coop + "\n";
    const line = "}\n";
    Header += line;
    XSingle += line;
    HSingle += line;
    MSingle += line;
    ESingle += line;
    XLead += line;
    HLead += line;
    MLead += line;
    ELead += line;
    XBass += line;
    HBass += line;
    MBass += line;
    EBass += line;
    XDrums += line;
    HDrums += line;
    MDrums += line;
    EDrums += line;
    Events += line;
  }
  function writeSync(track) {
    Sync += "[SyncTrack]\n{\n";
    let tick = 0;
    let event;
    for (let i = 0; i < track.length; i++) {
      tick += Math.round(track[i].deltaTime * scaler);
      event = track[i];
      if (event.type === "trackName") {
        chartName = '"' + event.text + '"';
      } else if (event.type === "setTempo") {
        const mpq = event.microsecondsPerBeat;
        const bpm = Math.floor(6e7 / mpq * 1e3);
        Sync += "	" + tick + " = B " + bpm + "\n";
      } else if (event.type == "timeSignature") {
        Sync += `	${tick} = TS ${event.numerator} ${Math.sqrt(
          event.denominator
        )}
`;
      } else if (event.type == "marker" && !hasEvents) {
        writeEventLine(4, tick, "section " + event.text);
      }
    }
    Sync += "}\n";
  }
  function writeNoteSection(track, sec) {
    const skip = Array.from({ length: track.length }, () => false);
    const isEvents = track.some(
      (a) => a.type === "trackName" && a.text === "EVENTS"
    );
    let i;
    let tick = 0;
    for (i = 0; i < track.length; i++) {
      if (!skip[i]) {
        const event = track[i];
        tick += Math.round(track[i].deltaTime * scaler);
        if (event.type === "noteOn") {
          const note = event.noteNumber;
          let off = -1;
          let j = i + 1;
          let jtick = tick;
          while (off < 0 && j != track.length) {
            const e = track[j];
            jtick += Math.round(e.deltaTime * scaler);
            if (e.type === "noteOn" || e.type === "noteOff") {
              if (e.noteNumber === note) {
                off = jtick;
                if (e.type === "noteOn") {
                  skip[j] = true;
                }
              }
            }
            j++;
          }
          let sustain = off - tick;
          if (sustain < 96) {
            sustain = 0;
          }
          writeNoteLine(sec, tick, note, sustain);
        } else if (isEvents && event.type === "text") {
          const validEvents = sec - 4 === 0 ? TRACK_0_EVENTS : STANDARD_EVENTS;
          const text = event.text;
          if (validEvents.includes(text) || text.includes("[section ")) {
            writeEventLine(sec, tick, event.text.substring(1, text.length - 1));
          }
        }
      }
    }
  }
  function writeNoteLine(section, tick, note, sustain) {
    const n = note % 12;
    let line = "";
    if (n >= 0 && n <= 4) {
      line = "	" + tick + " = N " + n + " " + sustain + "\n";
    } else if (n == 7) {
      line = "	" + tick + " = S 2 " + sustain + "\n";
    } else if (n == 9) {
      line = "	" + tick + " = S 0 " + sustain + "\n";
    } else if (n == 10) {
      line = "	" + tick + " = S 1 " + sustain + "\n";
    } else {
      return;
    }
    let diff = "";
    if (note >= 60)
      diff = "Easy";
    if (note >= 72)
      diff = "Medium";
    if (note >= 84)
      diff = "Hard";
    if (note >= 96)
      diff = "Expert";
    if (diff === "Expert") {
      if (section == 0) {
        XSingle += line;
      } else if (section == 1) {
        XLead += line;
      } else if (section == 3) {
        XBass += line;
      } else if (section == 5) {
        XDrums += line;
      }
    } else if (diff === "Hard") {
      if (section == 0) {
        HSingle += line;
      } else if (section == 1) {
        HLead += line;
      } else if (section == 3) {
        HBass += line;
      } else if (section == 5) {
        HDrums += line;
      }
    } else if (diff === "Medium") {
      if (section == 0) {
        MSingle += line;
      } else if (section == 1) {
        MLead += line;
      } else if (section == 3) {
        MBass += line;
      } else if (section == 5) {
        MDrums += line;
      }
    } else if (diff === "Easy") {
      if (section == 0) {
        ESingle += line;
      } else if (section == 1) {
        ELead += line;
      } else if (section == 3) {
        EBass += line;
      } else if (section == 5) {
        EDrums += line;
      }
    }
  }
  function writeEventLine(sec, tick, event) {
    let e = event;
    if (sec == 4) {
      e = '"' + event + '"';
    }
    const line = "	" + tick + " = E " + e + "\n";
    if (sec == 4) {
      Events += line;
    } else if (sec == 0) {
      XSingle += line;
      HSingle += line;
      MSingle += line;
      ESingle += line;
    } else if (sec == 1) {
      XLead += line;
      HLead += line;
      MLead += line;
      ELead += line;
    } else if (sec == 3) {
      XBass += line;
      HBass += line;
      MBass += line;
      EBass += line;
    }
  }
  main();
  const parts = [
    Header,
    Sync,
    Events,
    XSingle,
    HSingle,
    MSingle,
    ESingle,
    XLead,
    HLead,
    MLead,
    ELead,
    XBass,
    HBass,
    MBass,
    EBass,
    XDrums,
    HDrums,
    MDrums,
    EDrums
  ];
  return parts.filter((a) => {
    if (options.omitEmptySections && a.split("\n").length === 4) {
      return false;
    }
    return true;
  }).join("\n").replace(/\n+/g, "\n");
}
function disToTime(tickStart, tickEnd, resolution, bpm) {
  return (tickEnd - tickStart) / resolution * 60 / bpm;
}
function getTimedBpms(bpms, resolution) {
  const result = [];
  let time = 0;
  let prevBpm = bpms[0];
  for (const ev of bpms) {
    time += disToTime(prevBpm.tick, ev.tick, resolution, prevBpm.bpm);
    result.push({
      ...ev,
      assignedTime: time
    });
    prevBpm = ev;
  }
  return result;
}
function timeToDis(timeStart, timeEnd, resolution, bpm) {
  return Math.round((timeEnd - timeStart) * bpm / 60 * resolution);
}
function findClosestPosition(tick, events) {
  let lowerBound = 0;
  let upperBound = events.length - 1;
  let index = -1;
  let midPoint = -1;
  while (lowerBound <= upperBound) {
    midPoint = Math.floor((lowerBound + upperBound) / 2);
    index = midPoint;
    if (events[midPoint].tick == tick) {
      break;
    } else {
      if (events[midPoint].tick < tick) {
        lowerBound = midPoint + 1;
      } else {
        upperBound = midPoint - 1;
      }
    }
  }
  return index;
}
function tickToTime(tick, resolution, bpms) {
  let previousBPMPos = findClosestPosition(tick, bpms);
  if (bpms[previousBPMPos].tick > tick)
    --previousBPMPos;
  const prevBPM = bpms[previousBPMPos];
  let time = prevBPM.assignedTime;
  time += disToTime(prevBPM.tick, tick, resolution, prevBPM.bpm);
  return time;
}
function getTimedTrack(arr, resolution, bpms) {
  return arr.map((a) => ({
    ...a,
    assignedTime: tickToTime(a.tick, resolution, bpms)
  }));
}
function findLastTimeEvent(time, events, equal = true) {
  let last = events[0];
  for (let i = 0; i < events.length; ++i) {
    const ev = events[i];
    if (equal && ev.assignedTime >= time || ev.assignedTime > time)
      break;
    else
      last = ev;
  }
  return last;
}
function timeToTick(time, resolution, bpms) {
  if (time < 0)
    time = 0;
  const prevBPM = findLastTimeEvent(time, bpms);
  let position = 0;
  position = prevBPM.tick;
  position += timeToDis(prevBPM.assignedTime, time, resolution, prevBPM.bpm);
  return position;
}
const difficulties = ["Easy", "Medium", "Hard", "Expert"];
const instruments = [
  "Single",
  "DoubleBass",
  "DoubleRhythm",
  "Keyboard",
  "DoubleGuitar",
  "Vocals"
];
const requiredSections = ["Song", "SyncTrack"];
const sectionTitleRegex = /^\[(.+)\]$/;
const commonLineRegex = /^(.+)\s+=\s+(.+)$/;
const quotedStringRegex = /^\"|\"$/g;
const syncTrackEventRegex = /^(TS|B)\s+(.+)/;
const simpleEventRegex = /^E\s+(.+)/;
const starPowerEventRegex = /^S\s+2\s+(\d+)/;
const noteEventRegex = /^N\s+(\d+)\s+(\d+)/;
const numericalSongSections = [
  "previewstart",
  "previewend",
  "difficulty",
  "offset",
  "resolution"
];
const instrumentTrackParsers = {
  Single: parseSingleSection,
  DoubleBass: parseSingleSection,
  DoubleGuitar: parseSingleSection,
  Keyboard: parseSingleSection,
  DoubleRhythm: parseSingleSection,
  Vocals: parseSingleSection
};
function parseStringLine(line, sectionTitle, warns) {
  const res = line.match(commonLineRegex);
  if (res === null || res.length !== 3) {
    warns.push(`Invalid [${sectionTitle}] entry '${line}'.`);
    return null;
  }
  return [res[1], res[2]];
}
function parseTickLine(line, sectionTitle, warns) {
  const stringLine = parseStringLine(line, sectionTitle, warns);
  if (!stringLine) {
    return null;
  }
  const tick = Number.parseInt(stringLine[0]);
  if (!Number.isInteger(tick)) {
    warns.push(`Invalid [${sectionTitle}] entry '${line}'.`);
    return null;
  }
  return [tick, stringLine[1]];
}
function parseAndSortTickLines(lines, sectionTitle, warns) {
  let tickEvents = lines.map((l) => parseTickLine(l, sectionTitle, warns)).filter((a) => a !== null);
  tickEvents = tickEvents.sort((a, b) => a[0] - b[0]);
  return tickEvents;
}
function parseSongSection(lines, warns) {
  const result = /* @__PURE__ */ Object.create(null);
  const parsedStringLines = lines.map((l) => parseStringLine(l, "Song", warns)).filter((a) => a !== null);
  for (const parsedLine of parsedStringLines) {
    const [key, value] = parsedLine;
    let valueFinal = value.replace(quotedStringRegex, "");
    const keyFinal = key.toLowerCase();
    if (numericalSongSections.includes(keyFinal)) {
      valueFinal = Number.parseFloat(valueFinal);
      if (!Number.isFinite(valueFinal)) {
        warns.push(`Invalid numerical [Song] entry: '${key} = ${value}'.`);
        continue;
      }
    }
    result[keyFinal] = valueFinal;
  }
  if (!("resolution" in result)) {
    throw new Error("Invalid [Song] section - missing 'resolution'.");
  }
  return result;
}
function parseSyncTrackEvent([tick, frag], warns) {
  const result = frag.match(syncTrackEventRegex);
  if (result === null || result.length !== 3) {
    throw new Error(`Failed to parse sync track event '${frag}'.`);
  }
  if (result[1] === "B") {
    const bpmRaw = Number.parseInt(result[2]);
    if (!Number.isFinite(bpmRaw)) {
      warns.push(`Invalid BPM '${frag}'.`);
      return null;
    }
    return {
      bpm: bpmRaw / 1e3,
      tick,
      type: "bpm"
    };
  } else if (result[1] === "TS") {
    const ts = result[2].trim().split(/\s+/);
    if (ts.length > 2) {
      warns.push(`Invalid TS '${frag}'.`);
      return null;
    }
    const numer = Number.parseInt(ts[0]);
    const denom = ts[1] ? Number.parseInt(ts[1]) : 2;
    if (!Number.isFinite(numer) || !Number.isFinite(denom)) {
      warns.push(`Invalid TS '${frag}'.`);
      return null;
    }
    return {
      numerator: numer,
      denominator: Math.pow(2, denom),
      tick,
      type: "ts"
    };
  } else {
    warns.push(`Unknown sync track event '${frag}'.`);
    return null;
  }
}
function parseSyncTrack(lines, warns) {
  const tickEvents = parseAndSortTickLines(lines, "SyncTrack", warns);
  const timeSignatures = [];
  const bpms = [];
  const allEvents = [];
  for (const [i, tickEvent] of tickEvents.entries()) {
    const event = parseSyncTrackEvent(tickEvent, warns);
    if (event === null) {
      warns.push(`Invalid [SyncTrack] entry '${lines[i]}'.`);
      continue;
    }
    allEvents.push(event);
    if (event.type === "bpm") {
      bpms.push(event);
    } else {
      timeSignatures.push(event);
    }
  }
  if (!bpms.some((e) => e.tick === 0)) {
    const baseBpm = {
      type: "bpm",
      tick: 0,
      bpm: 120
    };
    allEvents.unshift(baseBpm);
    bpms.unshift(baseBpm);
  }
  if (!timeSignatures.some((e) => e.tick === 0)) {
    const baseTs = {
      type: "ts",
      tick: 0,
      numerator: 4,
      denominator: 4
    };
    allEvents.unshift(baseTs);
    timeSignatures.unshift(baseTs);
  }
  return {
    timeSignatures,
    bpms,
    allEvents
  };
}
function parseSingleSection(sectionTitle, lines, resolution, bpms, warns) {
  const tickEvents = parseAndSortTickLines(lines, sectionTitle, warns);
  const validEventParsers = [
    parseNoteEvent,
    parseStarpowerEvent,
    parseSimpleEvent
  ];
  const result = [];
  function commitNoteBuffer() {
    const isChord = noteBuffer.filter((a) => a.note !== 5 && a.note !== 6).length > 1;
    noteBuffer.forEach((note) => {
      note.forced = modifierBuffer.forced && !modifierBuffer.tap;
      note.tap = modifierBuffer.tap;
      note.isChord = isChord;
    });
    result.push(...noteBuffer);
    noteBuffer = [];
    modifierBuffer.forced = false;
    modifierBuffer.tap = false;
  }
  let tick = tickEvents[0][0];
  let noteBuffer = [];
  let modifierBuffer = {
    forced: false,
    tap: false
  };
  for (const [i, tickEvent] of tickEvents.entries()) {
    if (tickEvent[0] !== tick) {
      commitNoteBuffer();
    }
    tick = tickEvent[0];
    let valid = false;
    for (const parserFn of validEventParsers) {
      const event = parserFn(tickEvent);
      if (event) {
        if (event.type === "note") {
          if (event.note === 5) {
            modifierBuffer.forced = true;
          } else if (event.note === 6) {
            modifierBuffer.tap = true;
          } else {
            noteBuffer.push(event);
          }
        } else {
          result.push(event);
        }
        valid = true;
        break;
      }
    }
    if (!valid) {
      warns.push(`Invalid [${sectionTitle}] entry '${lines[i]}'.`);
    }
  }
  commitNoteBuffer();
  const hopoThreshold = 65 / 192 * resolution;
  const notes = result.filter((a) => a.type === "note");
  const lastSeen = new Array(8).fill(null);
  for (const note of notes) {
    if (!note.tap) {
      if (note.isChord) {
        note.isHOPO = note.forced;
      } else {
        const shouldBeHOPO = lastSeen.some((tick2, n) => {
          return n !== note.note && tick2 && note.tick - hopoThreshold <= tick2;
        });
        note.isHOPO = note.forced ? !shouldBeHOPO : shouldBeHOPO;
      }
    }
    lastSeen[note.note] = note.tick;
  }
  return getTimedTrack(result, resolution, bpms);
}
function parseStarpowerEvent(tickEvent) {
  const match = tickEvent[1].match(starPowerEventRegex);
  if (match && match.length === 2) {
    const duration = Number.parseInt(match[1]);
    if (Number.isFinite(duration) && duration > 0) {
      return {
        type: "starpower",
        duration,
        tick: tickEvent[0]
      };
    }
  }
  return null;
}
function parseNoteEvent(tickEvent) {
  const match = tickEvent[1].match(noteEventRegex);
  if (match && match.length === 3) {
    const numbers = match.slice(1).map((v) => Number.parseInt(v));
    if (numbers.every((m) => Number.isFinite(m) && m >= 0)) {
      return {
        note: numbers[0],
        duration: numbers[1],
        isHOPO: false,
        forced: false,
        isChord: false,
        tap: false,
        type: "note",
        tick: tickEvent[0]
      };
    }
  }
  return null;
}
function parseSimpleEvent(tickEvent) {
  const frags = tickEvent[1].match(simpleEventRegex);
  if (frags === null || frags.length !== 2) {
    return null;
  }
  const value = frags[1].replace(quotedStringRegex, "");
  return {
    value,
    tick: tickEvent[0],
    type: "event"
  };
}
function parseEventsSection(sectionTitle, lines, resolution, bpms, warns) {
  const tickEvents = parseAndSortTickLines(lines, sectionTitle, warns);
  const result = [];
  for (const [i, tickEvent] of tickEvents.entries()) {
    const simpleEvent = parseSimpleEvent(tickEvent);
    if (simpleEvent) {
      result.push(simpleEvent);
    } else {
      warns.push(`Invalid [${sectionTitle}] entry '${lines[i]}'.`);
    }
  }
  return getTimedTrack(result, resolution, bpms);
}
function getSectionParser(title) {
  if (title === "Events") {
    return parseEventsSection;
  }
  for (const instrument of instruments) {
    const parseFn = instrumentTrackParsers[instrument];
    if (parseFn) {
      for (const diff of difficulties) {
        if (title === `${diff}${instrument}`) {
          return parseFn;
        }
      }
    }
  }
  return null;
}
function parseChartString(rawChart, warnings) {
  const lines = rawChart.split("\n").map((a) => a.trim()).filter((a) => a && a.length > 0);
  const sectionIndices = [];
  for (let i = 0; i < lines.length; i++) {
    if (sectionTitleRegex.test(lines[i])) {
      sectionIndices.push(i);
    }
  }
  const sections = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < sectionIndices.length; i++) {
    const startIndex = sectionIndices[i];
    const endIndex = sectionIndices[i + 1] ?? lines.length;
    const sectionTitleMatch = lines[startIndex].match(sectionTitleRegex);
    if (endIndex - startIndex > 3 && sectionTitleMatch && sectionTitleMatch.length >= 2) {
      const title = sectionTitleMatch[1];
      sections[title] = lines.slice(startIndex + 2, endIndex - 1);
    }
  }
  for (const sec of requiredSections) {
    if (!(sec in sections)) {
      throw new Error(`Missing [${sec}] section in chart.`);
    }
  }
  const Song = parseSongSection(sections["Song"], warnings);
  delete sections["Song"];
  const { resolution } = Song;
  const { timeSignatures, allEvents, bpms } = parseSyncTrack(
    sections["SyncTrack"],
    warnings
  );
  delete sections["SyncTrack"];
  const timedBpms = getTimedBpms(bpms, Song.resolution);
  const SyncTrack = {
    bpms: timedBpms,
    timeSignatures: getTimedTrack(timeSignatures, resolution, timedBpms),
    allEvents: getTimedTrack(allEvents, resolution, timedBpms)
  };
  const result = {
    Song,
    SyncTrack
  };
  for (const title of Object.keys(sections)) {
    const lines2 = sections[title];
    const sectionParserFn = getSectionParser(title);
    if (sectionParserFn === null) {
      warnings.push(`Unsupported chart section '[${title}]'.`);
    } else {
      result[title] = sectionParserFn(
        title,
        lines2,
        resolution,
        timedBpms,
        warnings
      );
    }
  }
  return result;
}
function parseChart(input) {
  const warnings = [];
  const chartString = typeof input === "string" ? input : mid2Chart(input, warnings);
  const chart = parseChartString(chartString, warnings);
  return {
    chart,
    warnings
  };
}
export {
  parseChart,
  tickToTime,
  timeToTick
};
